# Αρχιτεκτονική Υπολογιστών

**2o Εργαστήριο**  
**Ομάδα 10: Χελάκης Κωνσταντίνος Μάριος** 

# Ερωτήματα

# Βήμα 1ο:  

## 1ο Ερώτημα   
### Βρείτε τα μεγέθη των caches, το associativity κάθε μίας από αυτές και το μέγεθος της cache line  

Για να βρούμε αυτά τα μεγέθη ανοίγουμε σε οποιονδήποτε από τους παραγώμενους φακέλους το αρχείο *config.ini*  

Το μέγεθος της L1 Data cache φαίνεται στο tag *[system.cpu.dcache]* στην μεταβλητή ***size=65536*** (Bytes). Το associativity αναγράφεται στην μεταβλητή ***assoc=2***, η οποία δηλώνει ότι η dcache εχει 2-way set associativity.  

Το μέγεθος της L1 Instruction cache φαίνεται στο tag *[system.cpu.icache]* στην μεταβλητή ***size=32768*** (Bytes). Το associativity αναγράφεται στην μεταβλητή ***assoc=2***, η οποία δηλώνει ότι η icache εχει 2-way set associativity.

Το μέγεθος της cache line βρίσκεται στο tag *[system]*, στην μεταβλητή **cache_line_size=64** και δηλώνει ότι το μέγεθος του cache line ειναι 64 Bytes. 

Το μέγεθος της L2 cache φαίνεται στο στο tag *[system.l2.tags]* στην μεταβλητή ***size=2097152*** (Bytes). Το associativity αναγράφεται στην μεταβλητή ***assoc=8***, η οποία δηλώνει ότι η L2 cache εχει 8-way set associativity.  

## 2ο Ερώτημα 
### Καταγράψτε τα αποτελέσματα από διαφορετικά benchmarks (i) χρόνο εκτέλεσης, (ii) CPI, (iii) miss rates 

Εκτελούμε αρχικά τα benchmarks που δόθηκαν στις οδηγίες: 

* **401.bzip2:** Το ακόλουθο benchmark εκτελείται πληκτρολογώντας την παρακάτω εντολή: 

'$ ./build/ARM/gem5.opt -d spec_results/specbzip configs/example/se.py --cpu-type=MinorCPU --caches --l2cache -c spec_cpu2006/401.bzip2/src/specbzip -o "spec_cpu2006/401.bzip2/data/input.program 10" -I 100000000'

Τα αποτελέσματα θα αποκηθευτούν στον φάκελο *speczib*, ο επεξεργαστής που χρησιμοποιείται είναι ο *MinorCPU*.

* **429.mcf:** Το ακόλουθο benchmark εκτελείται πληκτρολογώντας την παρακάτω εντολή: 

'$ ./build/ARM/gem5.opt -d spec_results/specmcf configs/example/se.py --cpu-type=MinorCPU --caches --l2cache -c spec_cpu2006/429.mcf/src/specmcf -o "spec_cpu2006/429.mcf/data/inp.in" -I 100000000'

Τα αποτελέσματα θα αποκηθευτούν στον φάκελο *specmcf*, ο επεξεργαστής που χρησιμοποιείται είναι ο *MinorCPU*.

* **456.hmmer:** Το ακόλουθο benchmark εκτελείται πληκτρολογώντας την παρακάτω εντολή: 

'$ ./build/ARM/gem5.opt -d spec_results/spechmmer configs/example/se.py --cpu-type=MinorCPU --caches --l2cache -c spec_cpu2006/456.hmmer/src/spechmmer -o "--fixed 0 --mean 325 --num 45000 --sd 200 --seed 0 spec_cpu2006/456.hmmer/data/bombesin.hmm" -I 100000000'

Τα αποτελέσματα θα αποκηθευτούν στον φάκελο *spechmmer*, ο επεξεργαστής που χρησιμοποιείται είναι ο *MinorCPU*. 

* **458.sjeng:** Το ακόλουθο benchmark εκτελείται πληκτρολογώντας την παρακάτω εντολή: 

'$ ./build/ARM/gem5.opt -d spec_results/specsjeng configs/example/se.py --cpu-type=MinorCPU --caches --l2cache -c spec_cpu2006/458.sjeng/src/specsjeng-o "spec_cpu2006/458.sjeng/data/test.txt" -I 100000000'

Τα αποτελέσματα θα αποκηθευτούν στον φάκελο *specsjeng*, ο επεξεργαστής που χρησιμοποιείται είναι ο *MinorCPU*.  

* **470.lbm:** Το ακόλουθο benchmark εκτελείται πληκτρολογώντας την παρακάτω εντολή: 

'$ ./build/ARM/gem5.opt -d spec_results/speclibm configs/example/se.py --cpu-type=MinorCPU --caches --l2cache -c spec_cpu2006/470.lbm/src/speclibm -o "20 spec_cpu2006/470.lbm/data/lbm.in 0 1 spec_cpu2006/470.lbm/data/100_100_130_cf_a.of" -I 100000000'

Τα αποτελέσματα θα αποκηθευτούν στον φάκελο *speclibm*, ο επεξεργαστής που χρησιμοποιείται είναι ο *MinorCPU*. 

**Τα αποτελέσματα μετά την εκτέλεση των παραπάνω benchmarks αναγράφονται στον παρακάτω πίνακα:**  

|          |sim_seconds	|CPI	|miss_rate dcache	|miss_rate icache	|miss_rate l2cache |
|---|---|---|---|---|---|
|specbzip	 |0.083982	|1.67965	 |0.014798	|0.00007	|0.282163 |
|specmcf	 |0.064955	|1.299095	 |0.002108	|0.023612	|0.055046 |
|spechmmer |0.059396	|1.187917	 |0.001637	|0.000221	|0.07776  |
|specsjeng |0.513528	|10.270554 |0.121831	|0.0002	  |0.999972 |
|speclibm	 |0.174671	|3.4934	   |0.060972	|0.00094	|0.99944  |

**Διάγραμμα Αποτελεσμάτων**

![Chart 1: Seconds Simulated](/Lab2/Charts/sim_seconds.png)  
![Chart 2: CPI per benchmark](/Lab2/Charts/cpi.png)  
![Chart 3: Miss Rate icashe](/Lab2/Charts/miss_rate_icache.png)  
![Chart 4: Miss Rate dcache](/Lab2/Charts/miss_rate_dcache.png)  
![Chart 5: Miss Rate L2 cache](/Lab2/Charts/miss_rate_l2.png)  


Από τα παραπάνω αποτελέσματα βλέπουμε ότι όσο αυξάνονται το miss rate της L2 cache (σε μεγαλύτερο βαθμό) και της L1 cache (σε μικρότερο βαθμό) , τόσο αυξάνεται και το CPI. Αυτό είναι λογικό αφού το CPI εξαρτάται από τα miss rates τόσο της L2 cache όσο και των L1 icache και dcache. 

Συνεπώς στα δύο benchmarks με τους μεγαλύτερους χρόνους (sjeng και libm) είναι αυτά που χουν τα περισσότερα L2 miss rates και συνεπώς το μεγαλύτερο CPI. Αυτό συμβαίνει διότι η L2 cache είναι σχετικά πιο αργή από την L1 cache με συνέπεια τα misses να στοιχίζουν πιο πολύ σε χρόνο για το σύστημα μας.

Η L1 cache είναι πιο γρήγορη μνήμη και για αυτό τα misses δεν παίζουν ιδιαίτερο ρόλο στο CPI. Αυτό μπορούμε να το διαπιστώσουμε στα δύο πρώτα benchmarks (bzip και mcf) τα οποία ενώ εμφανίζουν σχετικά μεγαλύτερο miss rate στην dcache και icache, δεν επιρεάζουν σε μεγάλο βαθμό το CPI. 

## 3ο Ερώτημα 
### Τρέξτε ξανά τα benchmarks με cpu-clock=1GHz και εντοπίστε τις πληροφορίες για το ρολόι.

Στα παραγώμενα αρχεία config.ini του κάθε benchmark μπορούμε να βρούμε τα tags *[system.clk_domain]* και *[system.cpu.clk_domain]* τα οποία περιέχουν χρήσιμες πληροφορίες για τους χρόνους χρονισμού του επεξεργαστή και του συστήματος και τα οποία θα πρέπει να δούμε αναλυτικότερα.  

#### [system.clk_domain]

Το tag *[system.cpu_clk_domain]* αναφέρεται στην ταχύτητα του συστήματος και είναι by default ρυθμισμένο στα 1GHz. Στο αρχείο config.ini, παρατηρούμε ότι το tag αυτό το οποίο επιρεάζει τα clk_domain (δηλαδή την ταχύτητα) των εξής στοιχείων:  

* **[system.dvfs_handler]:** Μνήμη dcache  
* **[system.mem_ctrls]:** Ελεγκτές κύριας μνήμης  
* **[system.membus]** Κύρια μνήμη συστήματος   


#### [system.cpu_clk_domain]

Το tag *[system.cpu_clk_domain]* αναφέρεται στην ταχύτητα του επεξεργαστή και είναι αυτό το οποίο επιρρεάζεται με την εντολή *--cpu-clock*. Στο αρχείο config.ini, παρατηρούμε ότι το tag αυτό το οποίο επιρεάζει τα clk_domain (δηλαδή την ταχύτητα) των εξής στοιχείων:  

* **[system.cpu]:** Επεξεργαστής συστήματος  
* **[system.cpu.dcache]:** Μνήμη dcache  
* **[system.cpu.icache]:** Μνήμη icache  
* **[system.cpu.dtb.walker]**   
* **[system.cpu.itb.walker]**   
* **[system.cpu.l2]**  Μνήμη cache L2   

Στην εικόνα παρακάτω βλέπουμε το διάγραμμα config.dot.svg το οποίο μας δείχνει ένα σχηματικό του συστήματός μας.  

![Image 1: config.ini image](/Lab2/config.ini.png)  

Όπως βλέπομε υπάρχουν στοιχεία που βρίσκονται "εντός" του επεξεργαστή (L1 caches) τα οποία συγχρονίζονται με βάση το *[system.cpu_clk_domain]* και υπάρχουν στοιχεία που βρίσκονται "εκτός" του επεξεργαστή (L2, κύρια μνήμη, controllers) τα οποία συγχρονίζονται με βάση το *[system.clk_domain]*.  

Όπως μπορούμε να διαπιστώσομε η μνήμη cache L2 βρίσκεται **ανάμεσα στον επεξεργαστή και την κύρια μνήμη** με αποτέλεσμα να "βλέπει" και στις δύο διαφορετικές συχνότητες. Αυτό σημαίνει ότι η cache L2 θα πρέπει να μπορεί να επικοινωνήσει και στις δύο διαφορετικές συχνότητες (συχνότητα επεξεργαστή και συχνότητα συστήματος.  

Στο παρακάτω διάγραμμα φαίνονται τα αποτελέσματα από την εκτέλεση των benchmarks με **χρονισμό του επεξεργαστή στο 1GHz.**  

|          |sim_seconds	|CPI	|miss_rate dcache	|miss_rate icache	|miss_rate l2cache |
|---|---|---|---|---|---|
|specbzip	 |0.161025	|1.610247	 |0.014675	|0.000077	|0.282157 |
|specmcf	 |0.127942	|1.279422	 |0.002108	|0.023627	|0.055046 |
|spechmmer |0.118530	|1.185304	 |0.001629	|0.000221	|0.077747  |
|specsjeng |0.704056	|7.040561  |0.121831	|0.0002	  |0.999972 |
|speclibm	 |0.262327	|2.623265	 |0.060971	|0.00094	|0.999944  |  

Από τα αποτελέσματα συμπεραίνουμε ότι τα miss rate παραμένουν ίδια ωστόσο θα αναλύσουμε περισσότερο τον χρόνο εκτέλεσης και τα cpi. 

Στον παρακάτω πίνακα αντιπαρατίθενται τα αποτελέσματα από την εκτέλεση των προγραμμάτων με cpu clock στα 2GHz (αρχική εκτέλεση) και στο 1 GHz (τελευταία εκτέλεση): 

|           |sim_seconds @2GHz  |  sim_seconds @1GHz|  per % change |CPI @2GHz  |CPI @1GHz  |per % change |
|---        |---                |---                |---            |---        |---        |---          |
|specbzip	  |0.083982	          |0.161025	          |91,74%         |1.67965	  |1.610247	  |-4,13%       |
|specmcf	  |0.064955         	|0.127942           |96,97%         |1.299095	  |1.279422	  |-1,51%       |
|spechmmer  |0.059396	          |0.118530           |99,55%         |1.187917	  |1.185304	  |-0,02%       |
|specsjeng  |0.513528	          |0.704056           |37,10%         |10.270554  |7.040561   |-31,45%      |
|speclibm	  |0.174671	          |0.262327           |50,18%         |3.4934	    |2.623265	  |-24,91%      |

Μπορούμε να δούμε ότι τα benchmarks μπορούν να χωριστούν σε **δύο κατηγορίες ανάλογα με την συμπεριφορά που παρουσιάζουν.** Στην πρώτη κατηγορία είναι τα specs: bzip, mcf και hmmer στα οποία ο χρόνος εκτέλεσης **σχεδόν διπλασιάστηκε** και τα CPI έμειναν σχεδόν τα ίδια.  

Στην δεύτερη κατηγορία είναι τα υπόλοιπα 2: jeng και libm, στα οποία ο χρόνος εκτέλεσης **μεγάλωσε σημαντικά** όταν μειώσαμε την ταχύτητα του επεξεργαστή αλλά δεν διπλασιάστηκε ενώ τα CPI μειώθηκαν αρκετά.  

Άν δούμε τους παραπάνω πίνακες όπου αναγράφονται και τα miss rates, μπορούμε να βγάλουμε το συμπέρασμα ότι τα benchmarks τα δύο τελευταία specs που παρουσιάζουν αυτή την συμπεριφορά  (jeng και libm) είναι αυτά με το μεγαλύτερο miss_rate στην l2 cache. Συνεπώς μπορούμε να καταλήξουμε ότι η L2 Cache παίζει σημαντικό ρόλο στην ταχύτητα εκτέλεσης των προγραμμάτων.


Σε περίπτωση που προσθέσουμε έναν ακόμη επεξεργαστή **δεν θα υπάρξει διαφορά** αφού το πρόγραμμα μας εκτελείται σε έναν πυρήνα και δεν υποστηρίζει την παράλληλη επεξεργασία. 


# Βήμα 2ο:  

## 1ο Ερώτημα   
### Προσπαθήστε να πετύχετε την μέγιστη απόδοση του συστήματος τροποποιόντας τις παραμέτρους του συστήματος.

Πρκοκειμένου να πετύχουμε την μέγιστη απόδοση του συστήματος θα ξεκινήσουμε αλλάζοντας μία μία τις παραμέτρους και ελέγχοντας τι επιπτώσεις έχουν οι αλλαγές μας στην απόδοση του συστήματος. Ως παράδειγμα θα πάρουμε το πρώτο benchmark **bzip** το οποίο by default εχει τις εξής παραμέτρους: 

* **L1 icache** *size=32kB* & *assoc=2*  
* **L1 dcache** *size=64kB* & *assoc=2*  
* **L2 cache** *size=2048kB* & *assoc=8*  
* *cache line size=64B*  

Με αυτές τις παραμέτρους τα αποτελέσματα που παίρνουμε είναι τα εξής: **sim seconds = 0.161025** & **cpi = 1.67965**  

Παρακάτω θα τροποποιήσουμε μία μία τις παραμέτρους αυτές έτσι ώστε να δούμε τι επίδραση έχουν στην απόδοση του συστήματος.  

### Μέγεθος μνήμης cache L1  (icache & dcache) 
*[Σημείωση: ο λόγος που δεν αλλάζω ξεχωριστά τις δύο μνήμες cache L1 είναι διότι αυτές οι δύο μνήμες συσχετίζονται πολύ μεταξύ τους και για εξοικωνόμιση χρόνου στις αναλύσεις]*

Αρχικά θα επιρρεάσουμε τα μεγέθη των μνημών της L1 cache. Πρώτα θα μειώσουμε την χωρητικότητά τους στο μισό (*icache 32kB -> **16kB** & dcache 64kB -> **32kB**)* και στην συνέχεια θα την διπλασιάσουμε (*icache 32kB -> **64kB** & dcache 64kB -> **128kB**)*. Δεν μπορώ να ανέβω παραπάνω καθώς θα ξεπεράσω το όριο των 256kB χωρητικότητα αθροιστικά.

**Τα αποτελέσματα φαίνονται στον παρακάτω πίνακα και διάγραμμα**  

|           |icache = 16kB & dcache = 32kB|icache = 32kB & dcache = 64kB (default)|icache = 64kB & dcache = 128kB|
|---        |---                |---                |---            |
|sim_seconds|0.18	          |0.161025	          |0.14         |
|**CPI**	  |**1.70**         	|**1.67965**         |**1.65**         |


Όπως μπορούμε να διαπιστώσουμε η αύξηση της χωρητικότητας των dcache και icache 


### Associativity μνήμης cache L1  (icache & dcache)  

Στη συνέχεια αλλάζουμε το associativity της L1 cache. Πρώτα θα το μειώσουμε από *2 σε **1*** και στην συνέχεια θα το αυξήσουμε από *2 σε **4** και σε **8**.*

**Τα αποτελέσματα φαίνονται στον παρακάτω πίνακα και διάγραμμα**  

|   |assoc = 1 |assoc = 2 (default) |assoc = 4 | assoc = 8 |
|---        |---                |---                |---            |--- |
|sim_seconds|0.18	          |0.161025	          |0.14         | 0.13 |
|**CPI**	  |**1.70**         	|**1.67965**         |**1.65**        |**1.65** |


Όπως μπορούμε να διαπιστώσουμε η μείωση του associativity των dcache και icache 

### Μέγεθος μνήμης cache L2  

Eπιρρεάζουμε το μεγέθη της L2 cache. Πρώτα θα μειώσουμε την χωρητικότητά (*L2 cache 2048kB i) -> **512kB** ii) -> **1024kB** )* και στην συνέχεια θα την διπλασιάσουμε (*L2 cache 2048kB i) -> **4096kB**)*. Δεν μπορώ να ανέβω παραπάνω καθώς θα ξεπεράσω το όριο των 4096kB χωρητικότητα.

**Τα αποτελέσματα φαίνονται στον παρακάτω πίνακα και διάγραμμα**  

|L2 cache size: | 512kB | 1024kB |2048kB (default) |4096kB | 
|---        |---        |---      |---                |---            |
|sim_seconds|0.18	    |0.17      |0.161025	          |0.14         | 
|**CPI**	  |**1.70**   |**1.71**  	|**1.67965**       |**1.65**        |


Όπως μπορούμε να διαπιστώσουμε η  


### Associativity μνήμης cache L2  

Στη συνέχεια αλλάζουμε το associativity της L1 cache. Πρώτα θα το μειώσουμε από *8 σε **2** και **4*** και στην συνέχεια θα το αυξήσουμε από *8 σε **16** .*

**Τα αποτελέσματα φαίνονται στον παρακάτω πίνακα και διάγραμμα**  

|   |assoc = 2 |assoc = 4  |assoc = 8 (default) | assoc = 16 |
|---        |---                |---                |---            |--- |
|sim_seconds|0.18	          |0.16	          |0.161025	         | 0.13 |
|**CPI**	  |**1.70**         	|**1.67**         |**1.67965**        |**1.65** |

### Μέγεθος cache line  



